package QuickStart.Basic;

import java.util.Random;

public class IntOperation {
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
    }
    // 四则运算，Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。
    public static void test1() {
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);
    }
    // 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：
    public static void test2() {
        int x = 12345 / 67; // 184
        // 求余运算使用%
        int y = 12345 % 67; // 12345÷67的余数是17
        System.out.println(x);
        System.out.println(y);
        // 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错
    }
    // 溢出
    public static void test3() {
        // 运算溢出，要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
        /*
        要解释上述结果，我们把整数2147483640和15换成二进制做加法：
          0111 1111 1111 1111 1111 1111 1111 1000
        + 0000 0000 0000 0000 0000 0000 0000 1111
        -----------------------------------------
          1000 0000 0000 0000 0000 0000 0000 0111
        由于最高位计算结果为1，因此，加法结果变成了一个负数。
        要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出：
         */
        long x2 = 2147483640;
        long y2 = 15;
        long sum2 = x2 + y2;
        System.out.println(sum2); // 2147483655
    }
    // 简写的运算符
    public static void test4() {
        // 还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下
        int n = 3309;
        n += 100; // 3409, 相当于 n = n + 100;
        System.out.println(n); // 3409
        n -= 100; // 3309, 相当于 n = n - 100;
        System.out.println(n); // 3309
    }
    // 自增/自减
    public static void test5() {
        // 注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。
        int n = 3300;
        n++; // 3301, 相当于 n = n + 1;
        n--; // 3300, 相当于 n = n - 1;
        int y = 100 + (++n); // 不要这么写
        System.out.println(y);
    }
    // 移位运算
    public static void test6() {
        // 在计算机中，整数总是以二进制的形式表示。
        // 例如，int类型的整数7使用4个字节表示的二进制如下：00000000 0000000 0000000 00000111
        // 可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28
        // 左移29位时，由于最高位变成1，因此结果变成了负数。
        int n = 7;       // 00000000 00000000 00000000 00000111 = 7
        int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
        int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
        int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
        int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
        System.out.println(n);
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        // 类似的，对整数28进行右移，结果如下：
        int n2 = 7;       // 00000000 00000000 00000000 00000111 = 7
        int a2 = n2 >> 1;  // 00000000 00000000 00000000 00000011 = 3
        int b2 = n2 >> 2;  // 00000000 00000000 00000000 00000001 = 1
        // int c2 = n >> 3;  // 00000000 00000000 00000000 00000000 = 0  结果总是0
        System.out.println(n2);
        System.out.println(a2);
        System.out.println(b2);
        // 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数
        int n3 = -536870912;
        int a3 = n3 >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
        int b3 = n3 >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
        System.out.println(n3);
        System.out.println(a3);
        System.out.println(b3);
        // 还有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：
        int n4 = -536870912;
        int a4 = n4 >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
        int b4 = n4 >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
        int c4 = n4 >>> 29; // 00000000 00000000 00000000 00000111 = 7
        int d4 = n4 >>> 31; // 00000000 00000000 00000000 00000001 = 1
        System.out.println(a4);
        System.out.println(b4);
        System.out.println(c4);
        System.out.println(d4);
        // 对byte和short类型进行移位时，会首先转换为int再进行位移。
        // 仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。
    }
    // 位运算
    public static void test7() {
        // 位运算是按位进行与、或、非和异或的运算。
        // 与运算的规则是，必须两个数同时为1，结果才为1
        // n = 0 & 0; 结果为0
        // n = 0 & 1; 结果为0
        // n = 1 & 0; 结果为0
        // n = 1 & 1; 结果为1
        // 或运算的规则是，只要任意一个为1，结果就为1
        // n = 0 | 0; 结果为0
        // n = 0 | 1; 结果为1
        // n = 1 | 0; 结果为1
        // n = 1 | 1; 结果为1
        // 非运算的规则是，0和1互换
        // n = ~0; 结果为1
        // n = ~1; 结果为0
        // 异或运算的规则是，如果两个数不同，结果为1，否则为0：
        // n = 0 ^ 0; 结果为0
        // n = 0 ^ 1; 结果为1
        // n = 1 ^ 0; 结果为1
        // n = 1 ^ 1; 结果为0
        // Java没有单个bit的数据类型。在Java中，对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int n = 167776512; // 00001010 00000000 00010001 00000000
        // & -----------------------------------
        // 00001010 00000000 00010001 00000000
        System.out.println(i & n); // 167776512
        // 上述按位进行与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。
    }
    // 运算优先级
    public static void test8() {
        /*
        在Java的计算表达式中，运算优先级从高到低依次是：
        ()
        ! ~ ++ --
        * / %
        + -
        << >> >>>
        &
        |
        += -= *= /=
        记不住也没关系，只需要加括号就可以保证运算的优先级正确。
         */
    }
    // 类型自动提升与强制转型
    public static void test9() {
        // 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int
        short s = 1234;
        int i = 123456;
        int x = s + i; // s自动转型为int
        // short y = s + i; // 编译错误!
        System.out.println(s);
        System.out.println(i);
        System.out.println(x);
        // 也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short：
        int i2 = 12345;
        short s2 = (short) i; // 12345
        System.out.println(i2);
        System.out.println(s2);
        // 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节，因此，强制转型的结果很可能是错的。
        int i3 = 1234567;
        short s3 = (short) i3; // -10617
        System.out.println(s3);
        int i4 = 12345678;
        short s4 = (short) i4; // 24910
        System.out.println(s4);
    }
    // 练习
    public static void test10() {
        /*
        计算前N个自然数的和可以根据公式：
            (N+1)*N/2
        请根据公式计算前N个自然数的和
         */
        Random random = new Random();
        int n = random.nextInt(1000); // 随机生成 0~999 的整数
        long sum = ((long) (n + 1) * n) / 2;
        long expected = ((long) (n + 1) * n) / 2;
        System.out.println(sum);
        System.out.println(sum == expected ? "测试通过" : "测试失败");
    }

}
